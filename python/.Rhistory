ggplot(aes(x = date)) +
geom_xspline(aes(y = cases)) +
scale_y_continuous(labels = scales::label_comma()) +
theme_light()
wmc |>
ggplot(aes(x = date)) +
geom_line(aes(y = cases)) +
scale_y_continuous(labels = scales::label_comma()) +
theme_light()
# Importing packages ------------------------------------------------------
pacman::p_load(
dplyr,
ggplot2,
data.table,
lubridate,
ggalt,
patchwork,
stringr,
rKenyaCensus,
INLA,
inlabru,
tidyr,
readxl
)
# Importing data ----------------------------------------------------------
k <- fread("data/kenya_measles.csv")
co <- fread("data/county_measles.csv")
bdf2 <- readRDS("data/year_pop.rds")
who_cases <- read_excel("data/who_cases.xlsx")
who_month_cases <- read_excel("data/who_monthly_cases.xlsx")
who_vaccs <- read_excel("data/who_vaccs.xlsx")
who_inci <- read_excel("data/who_inci.xlsx")
# Data wrangling ----------------------------------------------------------
# Cleaning WHO cases
wc <- data.frame(t(who_cases))[-c(1:2),1] %>%
data.frame("cases" = ., year = rev(1980:2023)) |>
mutate(cases = as.numeric(str_remove_all(cases, "\\,")))
wi <- data.frame(t(who_inci))[-c(1:3),1] %>%
data.frame("inci" = ., year = rev(1980:2023)) |>
mutate(inci = as.numeric(str_remove_all(inci, "\\,")))
wmc <- who_month_cases %>%
setNames(str_to_lower(colnames(.))) |>
dplyr::select(-region, -iso3, -country) |>
data.table() |>
melt(id.vars = "year") |>
mutate(date = ymd(paste(year, str_to_title(variable), "01", sep = "-"))) |>
dplyr::select(date, cases = value) |>
mutate(cases = as.numeric(cases))
k2 <- k |>
_[, .(
month = str_split(periodname, " ", simplify = T)[,1],
year = str_split(periodname, " ", simplify = T)[,2],
deaths = `IDSR Measles Deaths`,
cases = `IDSR Measles Total`,
mcv1 = `Proportion of under 1 year receiving vaccine against Measles and Rubella 1`,
mcv2 = `Proportion of under two years receiving  vaccine against Measles and Rubella 2`
)] |>
_[, date := ymd(paste(year, month, "01", sep = "-"))] |>
_[, !c("month", "year")] |>
setcolorder(c("date", "cases", "deaths", "mcv1", "mcv2"))
# Population dataset ------------------------------------------------------
# Age and population
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated") & !str_detect(age, "\\-"),] |>
_[, .(age = str_replace_all(age, "\\+", "") |> as.numeric(), value = total)]
fwrite(pop_age, "data/pop_age.csv", row.names = F)
# Population projections using INLA ---------------------------------------
mbdf2 <- merge(
bdf2 |> mutate(month = "Jun"),
expand.grid(
county = bdf2 |> pull(county) |> unique(),
Age = bdf2 |> pull(Age) |> unique(),
gender = bdf2 |> pull(gender) |> unique(),
year = c(bdf2 |> pull(year) |> unique(), 2026:2030),
month = month.abb
),
by = c('county', 'Age', 'gender', 'year', 'month'),
all = T
)
k2 |>
ggplot(aes(x = date)) +
geom_xspline(aes(y = cases)) +
theme_minimal()
wmc |>
filter(year >= 2000) |>
ggplot(aes(x = date)) +
geom_line(aes(y = cases)) +
scale_y_continuous(labels = scales::label_comma()) +
theme_light()
wmc |>
filter(date >= as.Date("2020-01-01")) |>
ggplot(aes(x = date)) +
geom_line(aes(y = cases)) +
scale_y_continuous(labels = scales::label_comma()) +
theme_light()
reticulate::repl_python()
# seir.R
# JRCP 06.05.09
# Updated for 2012
#
# NOTE: The model and parameters used in this tutorial modified from:
#
# Earn et al. _A Simple Model for Complex Dynamical Transitions in Epidemics._
# 2000; Science 287: 667-670; DOI: 10.1126/science.287.5453.667
beta_calc <- function(
R_0, mu = 0.02 / 365.25, sigma = 1 / 8, gamma = 1 / 5
) {
R_0 / ((sigma / (mu + sigma)) * (1 / (mu + gamma)))
}
S.star <- function(
beta, N, mu = 0.02 / 365.25, sigma = 1 / 8, gamma = 1 / 5
) {
N * ((mu + sigma) / beta) * ((mu + gamma) / sigma)
}
E.star <- function(
beta, N, mu = 0.02 / 365.25, sigma = 1 / 8, gamma = 1 / 5
) {
mu * (N - S.star(beta, N, mu, sigma, gamma)) / (mu + sigma)
}
I.star <- function(
beta, N, mu = 0.02 / 365.25, sigma = 1 / 8, gamma = 1 / 5
) {
(sigma / (mu + gamma)) * E.star(beta, N, mu, sigma, gamma)
}
R.star <- function(
beta, N, mu = 0.02 / 365.25, sigma = 1 / 8, gamma = 1 / 5
) {
(gamma / mu) * I.star(beta, N, mu, sigma, gamma)
}
N0 <- 500000
S.star(beta_calc(13), N0) +
E.star(beta_calc(13), N0) +
I.star(beta_calc(13), N0) +
R.star(beta_calc(13), N0)
S.star(beta_calc(18), N0)
E.star(beta_calc(18), N0)
I.star(beta_calc(18), N0)
R.star(beta_calc(18), N0)
E.star(beta_calc(13), N0) + I.star(beta_calc(13), N0)
E.star(beta_calc(18), 300000) + I.star(beta_calc(18), 300000)
E.star(beta_calc(13), 7200) + I.star(beta_calc(13), 7200)
E.star(beta_calc(18), 7200) + I.star(beta_calc(18), 7200)
## NOTE: The rest of the script is used for the BONUS question.
## You are encouraged to continue commenting the script below this
## line but you should first complete benchmark questions 3 and
## 4 to ensure that you have mastered the script up to this point.
library(deSolve)
seir <- function(t, y, params) {
S <- y[1]
E <- y[2]
I <- y[3]
R <- y[4]
beta <- params["beta"]
N <- params["N"]
mu <- params["mu"]
sigma <- params["sigma"]
gamma <- params["gamma"]
nu <- mu * N
dSdt <- nu - (beta * S * I / N) - (mu * S)
dEdt <- (beta * S * I / N) - (mu * E) - (sigma * E)
dIdt <- (sigma * E) - (mu * I) - (gamma * I)
dRdt <- (gamma * I) - (mu * R)
return(list(c(dSdt, dEdt, dIdt, dRdt)))
}
## Note that N0 is defined earlier in the script as 500,000.
param_vals <- c(
beta = beta_calc(18), N = N0, mu = 0.02 / 365.25, sigma = 1 / 8, gamma = 1 / 5
)
times <- seq(0, 70 * 365, 10)
S0 <- 20000
E0 <- 200
I0 <- 125
## Stop and think about this. What is the level of immunity in
## the population for these initial conditions and a population
## size N0?
init <- c(sus = S0, exp = E0, inf = I0, rec = N0 - S0 - E0 -I0)
tc <- data.frame(lsoda(init, times, seir, param_vals))
plot(x = tc$time/365, y = tc$sus / N0,
type = "l", xlab = "Time (years)", ylab = "Proportion of population",
bty = "n", ylim = c(0, max(tc$sus / N0))
)
text(50, 1.1 * S.star(beta_calc(18), N0) / N0, "S(t)")
lines(tc$time / 365, (tc$exp + tc$inf) / N0, col = "green")
text(50, 0.2 * S.star(beta_calc(18), N0) / N0, "E(t)+I(t)", col = "green")
plot(tc$exp / N0, tc$sus / N0, type = "l", xlab = "EXP", ylab = "SUS", bty = "n")
points(E.star(beta_calc(18), N0) / N0, S.star(beta_calc(18), N0) / N0, pch = "*", col = "red")
points(E0 / N0, S0 / N0, col = "blue")
plot(tc$inf / N0, tc$sus / N0, type = "l", xlab = "INF", ylab = "SUS", bty = "n")
points(I.star(beta_calc(18), N0) / N0, S.star(beta_calc(18) , N0) / N0, pch = "*", col = "red")
points(I0 / N0, S0 / N0, col = "blue")
#' @section Benchmark Questions
#'
#' @question Comments?
#' This file contains code related to the SEIR model presented lectures, but the
#' code does not include any commenting. Add comments that describe the code
#' presented in seir.R. Make sure you understand each part of every line of the
#' code. You should be able to find the necessary information in the help files
#' for the `deSolve` library and the `lsoda()` function, but if anything also
#' feel free to ask the faculty or mentors for clarification.
#'
#' @question
#'
#' Use the functions E.star() and I.star() to fill in the missing parts of the
#' table on Slide 27 from this morning’s lecture:
#' That is, calculate the endemic equilibrium value for the number of infected
#' (exposed/latent + infectious) individuals in a population of 300,000 with an
#' R0 of 13 and in a population of 500,000 with an R0 of 18.
#'
#' @question
#'
#' Write a new function that calculates the number of infected
#' individuals the endemic equilibrium value for the number of infected
#' (exposed/latent + infectious) individuals in a population from the arguments
#' population.size and reproduction.number
#'
#' @tip
#'
#' answer should look like the following:
ei.star <- function(population.size, R0) {
ouptut <- `????` # some code here
return(output)
}
#' @question BONUS
#'
#' Using the seir() function as template, create a new function seir.seasonal()
#' that allows beta to vary with time. Define beta as a sinusoidal wave with a
#' period of 1 year, an amplitude of 0.08*β, and a mean value that would give
#' an R0 value of 18 for the non-seasonal model.
#' This script simulated data from the SEIR model. We also did some model fitting
#' using the Maximum Likelihood Estimate which also present in the script
#'
#' All the parameters used in the script (apart from the sinsidal function) were
#' adapted from the paper: A simple Model for Complex Dynamical Transitions in
#' Epidemics' which can be found from the following link:
#'
#' https://pubmed.ncbi.nlm.nih.gov/10650003/
#'
#' The sinosidual function was obtain from the paper: 'A century of transitions in New
#' York City's measles dynamics from the following link:
#'
#' https://royalsocietypublishing.org/doi/suppl/10.1098/rsif.2015.0024
#'
#' The file was prepared by Brian Njuguna and Group 4 project members on MMED-2024
#'
# Importing the packages --------------------------------------------------
pacman::p_load(data.table, deSolve, tidyverse, patchwork)
# Importing some data -----------------------------------------------------
demoDf <- fread('data/demoDF.csv')
setwd("~/Documents/GitHub/measlesMMED")
#' This script simulated data from the SEIR model. We also did some model fitting
#' using the Maximum Likelihood Estimate which also present in the script
#'
#' All the parameters used in the script (apart from the sinsidal function) were
#' adapted from the paper: A simple Model for Complex Dynamical Transitions in
#' Epidemics' which can be found from the following link:
#'
#' https://pubmed.ncbi.nlm.nih.gov/10650003/
#'
#' The sinosidual function was obtain from the paper: 'A century of transitions in New
#' York City's measles dynamics from the following link:
#'
#' https://royalsocietypublishing.org/doi/suppl/10.1098/rsif.2015.0024
#'
#' The file was prepared by Brian Njuguna and Group 4 project members on MMED-2024
#'
# Importing the packages --------------------------------------------------
pacman::p_load(data.table, deSolve, tidyverse, patchwork)
# Importing some data -----------------------------------------------------
demoDf <- fread('data/demoDF.csv')
myDat <- fread('data/myDat.csv')
# Collecting the parameter values -----------------------------------------
durationInfection <- 5 # The duration of infection
latentPeriod <- 8 # The latent period
N0 <- 6374980 # Initial population
#' The initial population to be used. The population was obtained from the 1944 total population
parms <- c(
beta0 = 2.06,  # The transmission parameter
alpha = 0.08  # The seasonal amplitude
)
# The state variables -----------------------------------------------------
y <- c(
S = .1 * 6374898,
E = .001* 6374898,
I = .001* 6374898,
R = 0,
Ci = 0
)
# Some more parameters of interest
deltat <- 1
times <- seq(from = as.Date('1944-01-03'), to = as.Date('1994-12-31'), by = 1)
# The SEIR model ----------------------------------------------------------
#' Simulate the SEIR Model
#'
#' This function simulates the Susceptible-Exposed-Infectious-Recovered (SEIR) model over a specified
#' time period. It uses a set of initial conditions and parameters to generate the model dynamics.
#' Some parameters are internally defined within the function to facilitate parameter isolation
#' during likelihood fitting.
#'
#' @param t A numeric vector of time points at which to evaluate the model.
#' @param y A numeric vector of initial conditions for the compartments:
#' Susceptible (S), Exposed (E), Infectious (I), Recovered (R), and Cumulative Incidence (Ci).
#' @param parms A list of parameters for the SEIR model including:
#' \describe{
#'   \item{beta0}{Baseline transmission rate.}
#'   \item{alpha}{Amplitude of seasonal variation in transmission rate.}
#'   \item{latentPeriod}{Average duration of the latent period.}
#'   \item{durationInfection}{Average duration of the infectious period.}
#' }
#' @return A list of the derivatives of the SEIR compartments at each time point. The list contains:
#' \describe{
#'   \item{dSdt}{Rate of change of the Susceptible population.}
#'   \item{dEdt}{Rate of change of the Exposed population.}
#'   \item{dIdt}{Rate of change of the Infectious population.}
#'   \item{dRdt}{Rate of change of the Recovered population.}
#'   \item{dCidt}{Rate of change of the Cumulative Incidence.}
#' }
#' @examples
#' \dontrun{
#' times <- seq(0, 100, by = 1)
#' init <- c(S = 999, E = 1, I = 0, R = 0, Ci = 0)
#' parameters <- list(beta0 = 0.3, alpha = 0.1, latentPeriod = 5, durationInfection = 7)
#' seir(times, init, parameters)
#' }
#' @export
seir <- \(t, y, parms) {
with(c(as.list(y), parms), {
N = sum(y)
# Fixed parameters
delta = 0
mu = .02/365                                     # The death rate
b = .02/365                                      # The birth rate
sigma = 1 / latentPeriod                       # Progression rate from pre-infectious to Infectious
gamma = 1 / durationInfection                  # Recovery rate
births = b * N
beta <- beta0 * (1 + alpha * cos(2 * pi * (t)))
dSdt = births - mu * S - beta * S * I / N
dEdt = beta * S * I / N - mu * E - sigma * E
dIdt = sigma * E - I * (mu + delta) - gamma * I
dRdt = gamma * I - mu * R
dCidt = sigma * E
return(list(c(dSdt, dEdt, dIdt, dRdt, dCidt)))
})
}
# Solving the differential equations --------------------------------------
modelResultsDf <- lsoda(
y = y,
parms = parms,
func = seir,
times = seq(1, length(times), by = 1),
)
modelDf <- modelResultsDf |>
as.data.frame() |>
mutate(time = times) |>
mutate(week_end = ceiling_date(time, "week", change_on_boundary = FALSE) - 2) |>
group_by(date = week_end) %>%
summarize(
weekly_incidence = last(Ci) - first(Ci),
.groups = 'drop',
across(c(S, E, I, R), ~ sum(.)),
N = S + E + I + R,
P = I / N
)
# Plotting ----------------------------------------------------------------
modelResults <- modelDf |>
filter(date > as.Date('1950-01-01')) |>
ggplot() +
geom_line(aes(x = date, y = weekly_incidence), col = 'red') +
theme_classic() +
theme(
axis.line = element_line(color = 'black'),
axis.text = element_text(color = 'black'),
axis.title = element_text(color = 'black'),
plot.title = element_text(color = 'black', hjust = .5)
) +
labs(x = 'days', y = 'Measles cases')
modelResults
ggsave(
'images/birth0.01375.png',
width = 10,
height = 6,
dpi = 1e3,
bg = NULL
)
# Comparing to our own data
dfCompare <- modelDf |>
data.frame() |>
mutate(cases = demoDf$cases)
pltCompareFirst <- dfCompare |>
filter(date > as.Date('1950-01-01')) |>
ggplot(aes(x = date)) +
geom_point(aes(y = cases), col = 'red') +
geom_line(aes(y = weekly_incidence)) +
theme_classic() +
theme(
axis.line = element_line(color = 'black'),
axis.text = element_text(color = 'black'),
axis.title = element_text(color = 'black'),
plot.title = element_text(color = 'black', hjust = .5)
) +
labs(x = 'Year', y = 'Weekly incidence')
pltCompareFirst
ggsave(
'images/birth0.02.png',
width = 10,
height = 6,
dpi = 1e3,
bg = NULL
)
# Several birth rates -----------------------------------------------------
#' Simulate the SEIR Model for Different Birth Rates
#'
#' This function simulates the SEIR model for different birth rates. It takes in a
#' set of parameters and a vector of birth rates, evaluates the SEIR model at
#' each birth rate, and returns the results as a list of data frames.
#'
#' @param parms A list of parameters for the SEIR model, including:
#' \describe{
#'   \item{beta0}{Baseline transmission rate.}
#'   \item{alpha}{Amplitude of seasonal variation in transmission rate.}
#'   \item{latentPeriod}{Average duration of the latent period.}
#'   \item{durationInfection}{Average duration of the infectious period.}
#' }
#' @param births A numeric vector of birth rates to evaluate.
#' @param ... Additional arguments passed to the model.
#' @return A list of data frames, each containing the results of the SEIR model
#' simulation for a given birth rate. Each data frame includes:
#' \describe{
#'   \item{date}{Date of the observation (week ending).}
#'   \item{weekly_incidence}{Weekly incidence of the disease.}
#'   \item{S}{Number of susceptible individuals.}
#'   \item{E}{Number of exposed individuals.}
#'   \item{I}{Number of infectious individuals.}
#'   \item{R}{Number of recovered individuals.}
#'   \item{N}{Total population (S + E + I + R).}
#'   \item{P}{Prevalence of the disease (I / N).}
#' }
#' @examples
#' \dontrun{
#' parms <- list(beta0 = 0.3, alpha = 0.1, latentPeriod = 5, durationInfection = 7)
#' births <- c(0.01, 0.02, 0.03, 0.04, 0.05)
#' results <- diffBirths(parms, births)
#' }
#' @export
diffBirths <- \(parms, births, ...) {
map2(births, as.character(births), \(b, name) {
# The parameters for the model
parms <- c(b, parms)
# The initial states
y <- c(
S = .1 * 6374898,
E = .001 * 6374898,
I = .001 * 6374898,
R = 0,
Ci = 0
)
# The function for the model
seir <- \(t, y, parms) {
with(c(as.list(y), parms), {
N = sum(y)
# Fixed parameters
delta = 0
mu = b / 365                                     # The death rate
b = b / 365                                      # The birth rate
sigma = 1 / latentPeriod                         # Progression rate from pre-infectious to Infectious
gamma = 1 / durationInfection                    # Recovery rate
births = b * N
beta <- beta0 * (1 + alpha * cos(2 * pi * (t)))
dSdt = births - mu * S - beta * S * I / N
dEdt = beta * S * I / N - mu * E - sigma * E
dIdt = sigma * E - I * (mu + delta) - gamma * I
dRdt = gamma * I - mu * R
dCidt = sigma * E
return(list(c(dSdt, dEdt, dIdt, dRdt, dCidt)))
})
}
cat(crayon::bold(crayon::cyan('Runing the model with birth rate:')), name, '\n')
modelResultsDf <- lsoda(
y = y,
parms = parms,
func = seir,
times = seq(1, length(times), by = 1),
)
modelDf <- modelResultsDf |>
as.data.frame() |>
mutate(time = times) |>
mutate(week_end = ceiling_date(time, "week", change_on_boundary = FALSE) - 2) |>
group_by(date = week_end) %>%
summarize(
weekly_incidence = last(Ci) - first(Ci),
.groups = 'drop',
across(c(S, E, I, R), ~ sum(.)),
N = S + E + I + R,
P = I / N
)
return(modelDf)
})
}
births <- c(seq(.01, .05, by = .01))
dfs <- diffBirths(parms = parms, births = births) %>%
setNames(c(paste0('birth_', as.character(births)))) %>%
map2(., names(.), \(x, y) {
x |>
data.table() %>%
.[, birth := y] %>%
.[, cases := demoDf$cases] %>%
.[date > as.Date('1950-12-31'),]
}) |> rbindlist()
reticulate::repl_python()
setwd("~/Documents/GitHub/ABM/python")
reticulate::repl_python()
