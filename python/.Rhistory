"""
Define measles model.
Adapted from https://github.com/optimamodel/gavi-outbreaks/blob/main/stisim/gavi/measles.py
Original version by @alina-muellenmeister, @domdelport, and @RomeshA
"""
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import starsim as ss
from starsim.diseases.sir import SIR
__all__ = ['Measles']
"""
Define measles model.
Adapted from https://github.com/optimamodel/gavi-outbreaks/blob/main/stisim/gavi/measles.py
Original version by @alina-muellenmeister, @domdelport, and @RomeshA
"""
__all__ = ['Measles']
class Measles(SIR):
def __init__(self, pars=None, *args, **kwargs):
""" Initialize with parameters """
super().__init__()
self.default_pars(
# Initial conditions and beta
beta=1.0,  # Placeholder value
init_prev=ss.bernoulli(p=0.005),
# Natural history parameters, all specified in days
dur_exp=ss.normal(loc=8),        # (days) - source: US CDC
dur_inf=ss.normal(loc=11),       # (days) - source: US CDC
p_death=ss.bernoulli(p=0.005),  # Probability of death
)
self.update_pars(pars=pars, **kwargs)
# SIR are added automatically, here we add E
self.add_states(
ss.BoolArr('exposed', label='Exposed'),
ss.FloatArr('ti_exposed', label='Time of exposure'),
)
return
@property
def infectious(self):
return self.infected | self.exposed
def update_pre(self):
# Progress exposed -> infected
ti = self.sim.ti
infected = (self.exposed & (self.ti_infected <= ti)).uids
self.exposed[infected] = False
self.infected[infected] = True
# Progress infected -> recovered
recovered = (self.infected & (self.ti_recovered <= ti)).uids
self.infected[recovered] = False
self.recovered[recovered] = True
# Trigger deaths
deaths = (self.ti_dead <= ti).uids
if len(deaths):
self.sim.people.request_death(deaths)
return
def set_prognoses(self, uids, source_uids=None):
""" Set prognoses for those who get infected """
super().set_prognoses(uids, source_uids)
ti = self.sim.ti
dt = self.sim.dt
self.susceptible[uids] = False
self.exposed[uids] = True
self.ti_exposed[uids] = ti
p = self.pars
# Determine when exposed become infected
self.ti_infected[uids] = ti + p.dur_exp.rvs(uids) / dt
# Sample duration of infection, being careful to only sample from the
# distribution once per timestep.
dur_inf = p.dur_inf.rvs(uids)
# Determine who dies and who recovers and when
will_die = p.p_death.rvs(uids)
dead_uids = uids[will_die]
rec_uids = uids[~will_die]
self.ti_dead[dead_uids] = self.ti_infected[dead_uids] + \
dur_inf[will_die] / dt
self.ti_recovered[rec_uids] = self.ti_infected[rec_uids] + \
dur_inf[~will_die] / dt
return
def update_death(self, uids):
# Reset infected/recovered flags for dead agents
for state in ['susceptible', 'exposed', 'infected', 'recovered']:
self.statesdict[state][uids] = False
return
import starsim as ss
pars = sc.objdict(
n_agents=5000,
birth_rate=20,
death_rate=20,
networks=ss.RandomNet()
)
measles = Measles()
"""
Define measles model.
Adapted from https://github.com/optimamodel/gavi-outbreaks/blob/main/stisim/gavi/measles.py
Original version by @alina-muellenmeister, @domdelport, and @RomeshA
"""
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import starsim as ss
from starsim.diseases.sir import SIR
__all__ = ['Measles']
"""
Define measles model.
Adapted from https://github.com/optimamodel/gavi-outbreaks/blob/main/stisim/gavi/measles.py
Original version by @alina-muellenmeister, @domdelport, and @RomeshA
"""
__all__ = ['Measles']
class Measles(SIR):
def __init__(self, pars=None, *args, **kwargs):
""" Initialize with parameters """
super().__init__()
self.default_pars(
# Initial conditions and beta
beta=1.0,  # Placeholder value
init_prev=ss.bernoulli(p=0.005),
# Natural history parameters, all specified in days
dur_exp=ss.normal(loc=8),        # (days) - source: US CDC
dur_inf=ss.normal(loc=11),       # (days) - source: US CDC
p_death=ss.bernoulli(p=0.005),  # Probability of death
)
self.update_pars(pars=pars, **kwargs)
# SIR are added automatically, here we add E
self.add_states(
ss.BoolArr('exposed', label='Exposed'),
ss.FloatArr('ti_exposed', label='Time of exposure'),
)
return
@property
def infectious(self):
return self.infected | self.exposed
def update_pre(self):
# Progress exposed -> infected
ti = self.sim.ti
infected = (self.exposed & (self.ti_infected <= ti)).uids
self.exposed[infected] = False
self.infected[infected] = True
# Progress infected -> recovered
recovered = (self.infected & (self.ti_recovered <= ti)).uids
self.infected[recovered] = False
self.recovered[recovered] = True
# Trigger deaths
deaths = (self.ti_dead <= ti).uids
if len(deaths):
self.sim.people.request_death(deaths)
return
def set_prognoses(self, uids, source_uids=None):
""" Set prognoses for those who get infected """
super().set_prognoses(uids, source_uids)
ti = self.sim.ti
dt = self.sim.dt
self.susceptible[uids] = False
self.exposed[uids] = True
self.ti_exposed[uids] = ti
p = self.pars
# Determine when exposed become infected
self.ti_infected[uids] = ti + p.dur_exp.rvs(uids) / dt
# Sample duration of infection, being careful to only sample from the
# distribution once per timestep.
dur_inf = p.dur_inf.rvs(uids)
# Determine who dies and who recovers and when
will_die = p.p_death.rvs(uids)
dead_uids = uids[will_die]
rec_uids = uids[~will_die]
self.ti_dead[dead_uids] = self.ti_infected[dead_uids] + \
dur_inf[will_die] / dt
self.ti_recovered[rec_uids] = self.ti_infected[rec_uids] + \
dur_inf[~will_die] / dt
return
def update_death(self, uids):
# Reset infected/recovered flags for dead agents
for state in ['susceptible', 'exposed', 'infected', 'recovered']:
self.statesdict[state][uids] = False
return
pars = sc.objdict(
n_agents=5000,
birth_rate=20,
death_rate=20,
networks=ss.RandomNet()
)
import sciris as sc
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import starsim as ss
from starsim.diseases.sir import SIR
__all__ = ['Measles']
"""
Define measles model.
Adapted from https://github.com/optimamodel/gavi-outbreaks/blob/main/stisim/gavi/measles.py
Original version by @alina-muellenmeister, @domdelport, and @RomeshA
"""
__all__ = ['Measles']
class Measles(SIR):
def __init__(self, pars=None, *args, **kwargs):
""" Initialize with parameters """
super().__init__()
self.default_pars(
# Initial conditions and beta
beta=1.0,  # Placeholder value
init_prev=ss.bernoulli(p=0.005),
# Natural history parameters, all specified in days
dur_exp=ss.normal(loc=8),        # (days) - source: US CDC
dur_inf=ss.normal(loc=11),       # (days) - source: US CDC
p_death=ss.bernoulli(p=0.005),  # Probability of death
)
self.update_pars(pars=pars, **kwargs)
# SIR are added automatically, here we add E
self.add_states(
ss.BoolArr('exposed', label='Exposed'),
ss.FloatArr('ti_exposed', label='Time of exposure'),
)
return
@property
def infectious(self):
return self.infected | self.exposed
def update_pre(self):
# Progress exposed -> infected
ti = self.sim.ti
infected = (self.exposed & (self.ti_infected <= ti)).uids
self.exposed[infected] = False
self.infected[infected] = True
# Progress infected -> recovered
recovered = (self.infected & (self.ti_recovered <= ti)).uids
self.infected[recovered] = False
self.recovered[recovered] = True
# Trigger deaths
deaths = (self.ti_dead <= ti).uids
if len(deaths):
self.sim.people.request_death(deaths)
return
def set_prognoses(self, uids, source_uids=None):
""" Set prognoses for those who get infected """
super().set_prognoses(uids, source_uids)
ti = self.sim.ti
dt = self.sim.dt
self.susceptible[uids] = False
self.exposed[uids] = True
self.ti_exposed[uids] = ti
p = self.pars
# Determine when exposed become infected
self.ti_infected[uids] = ti + p.dur_exp.rvs(uids) / dt
# Sample duration of infection, being careful to only sample from the
# distribution once per timestep.
dur_inf = p.dur_inf.rvs(uids)
# Determine who dies and who recovers and when
will_die = p.p_death.rvs(uids)
dead_uids = uids[will_die]
rec_uids = uids[~will_die]
self.ti_dead[dead_uids] = self.ti_infected[dead_uids] + \
dur_inf[will_die] / dt
self.ti_recovered[rec_uids] = self.ti_infected[rec_uids] + \
dur_inf[~will_die] / dt
return
def update_death(self, uids):
# Reset infected/recovered flags for dead agents
for state in ['susceptible', 'exposed', 'infected', 'recovered']:
self.statesdict[state][uids] = False
return
pars = sc.objdict(
n_agents=5000,
birth_rate=20,
death_rate=20,
networks=ss.RandomNet()
)
measles = Measles()
sim = ss.Sim(pars=pars, diseases=measles)
sim.run()
measles = Measles()
reticulate::repl_python()
library(reticulate)
py$sim
py
reticulate::repl_python()
py$sim$results
q()
library(reticulate)
reticulate::repl_python()
py$sim
repl_python()
q()
reticulate::repl_python()
setwd("~/Documents/GitHub/ABM/python")
# Importing packages ------------------------------------------------------
pacman::p_load(
dplyr,
ggplot2,
data.table,
lubridate,
ggalt,
patchwork,
stringr
)
# Importing data ----------------------------------------------------------
k <- fread("data/kenya_measles.csv")
co <- fread("data/county_measles.csv")
head(k)
k2 <- k |>
_[, .(
month = str_split(periodname, " ", simplify = T)[,1],
year = str_split(periodname, " ", simplify = T)[,2],
deaths = `IDSR Measles Deaths`,
cases = `IDSR Measles Total`,
mcv1 = `Proportion of under 1 year receiving vaccine against Measles and Rubella 1`,
mcv2 = `Proportion of under two years receiving  vaccine against Measles and Rubella 2`
)] |>
_[, date := ymd(paste(year, month, "01", sep = "-"))] |>
_[, !c("month", "year")] |>
setcolorder(c("date", "cases", "deaths", "mcv1", "mcv2"))
k2 |>
ggplot(aes(x = date)) +
geom_xspline(aes(y = cases)) +
theme_minimal()
reticulate::repl_python()
# SIR model with time-varying R0,eff
sir_model <- function(time, state, parameters) {
with(as.list(c(state, parameters)), {
# Calculate n(t)
n_t <- (birth_rate(time) - infant_mortality(time)) / N0 * (1 - vaccination_rate(time))
# Effective R0 calculation
R0_eff <- (n_t / n0) * R0
# Beta (transmission rate)
beta <- R0_eff * gamma
# SIR equations
dS <- -beta * S * I / N
dI <- beta * S * I / N - gamma * I
dR <- gamma * I
# Return derivatives
list(c(dS, dI, dR))
})
}
# Initial conditions
init <- c(S = 990, I = 10, R = 0) # Example initial values for S, I, and R
# Parameters
parameters <- c(
N = 1000,             # Total population
R0 = 3.5,             # Initial basic reproduction number
gamma = 1/14,         # Recovery rate
n0 = 0.02,            # Reference n0 (susceptible recruitment rate)
N0 = 1000             # Population size at anchor time
)
# Time sequence
times <- seq(0, 365, by = 1)
# Define birth, mortality, and vaccination rate functions
birth_rate <- function(t) { 10 } # Constant birth rate as an example
infant_mortality <- function(t) { 1 } # Constant infant mortality rate as an example
vaccination_rate <- function(t) { 0.5 } # Constant vaccination rate as an example
# Solve the model
output <- ode(y = init, times = times, func = sir_model, parms = parameters)
# Required library
library(deSolve)
# Solve the model
output <- ode(y = init, times = times, func = sir_model, parms = parameters)
# Convert output to a data frame for easier plotting
output <- as.data.frame(output)
output
# Plot the results
plot(output$time, output$S, type = "l", col = "blue", ylim = c(0, 1000), ylab = "Counts", xlab = "Time (days)")
lines(output$time, output$I, col = "red")
lines(output$time, output$R, col = "green")
legend("right", legend = c("Susceptible", "Infectious", "Recovered"), col = c("blue", "red", "green"), lty = 1)
reticulate::repl_python()
# handle beta here: at start of infection prior to transmission
beta_mean = 1  # Mean transmission rate
beta_amplitude = -1  # Amplitude of seasonal forcing
beta_phase = 10  # Phase shift of seasonal forcing (in months)
beta_period = 60  # Period of seasonal forcing (in months)
beta_rate = beta_mean * (1 + beta_amplitude * np.cos(2 * np.pi * (ti - beta_phase) / beta_period))
beta_prob = 1 - np.exp(-beta_rate)
reticulate::repl_python()
# handle beta here: at start of infection prior to transmission
beta_mean = 1  # Mean transmission rate
beta_amplitude = -1  # Amplitude of seasonal forcing
beta_phase = 10  # Phase shift of seasonal forcing (in months)
beta_period = 60  # Period of seasonal forcing (in months)
beta_rate = beta_mean * (1 + beta_amplitude * np.cos(2 * np.pi * (ti - beta_phase) / beta_period))
reticulate::repl_python()
k2 |>
ggplot(aes(x = date)) +
geom_xspline(aes(y = cases)) +
theme_minimal()
k2 |>
ggplot(aes(x = date)) +
geom_smooth(method = "gam", se = F)
k2 |>
ggplot(aes(x = date)) +
geom_smooth(aes(y = cases), method = "gam", se = F)
k2 |>
ggplot(aes(x = date)) +
geom_smooth(aes(y = cases), method = "gam", se = F)
k2 |>
ggplot(aes(x = date)) +
geom_xspline(aes(y = cases)) +
theme_minimal()
k2 |>
ggplot(aes(x = date)) +
geom_smooth(aes(y = cases), method = "loess", se = F)
k2 |>
ggplot(aes(x = date)) +
geom_smooth(aes(y = cases), method = "loess", se = F, span = .2)
plotly::ggplotly(
k2 |>
ggplot(aes(x = date)) +
geom_smooth(aes(y = cases), method = "loess", se = F, span = .2) +
theme_minimal()
)
plotly::ggplotly(
k2 |>
ggplot(aes(x = date)) +
geom_smooth(aes(y = cases), method = "loess", se = F, span = .1) +
theme_minimal()
)
reticulate::repl_python()
69+71+3+27+16/5
(69+71+3+27+16)/5
(123 + 102+10+30+10)/5
(1+2+4+3+5)/5
(41+26+13+9+17)/5
(5+2+4+4+5)/5
reticulate::repl_python()
pacman::p_load(
dplyr,
ggplot2,
data.table,
lubridate,
ggalt,
patchwork,
stringr,
rKenyaCensus
)
rKenyaCensus::V3_T2.2
View(rKenyaCensus::V3_T2.2)
pop_age <- View(rKenyaCensus::V3_T2.2) %>%
setNames(c(colnames(.)))
pop_age <- View(rKenyaCensus::V3_T2.2) %>%
setNames(c(colnames(.)))
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(colnames(.)))
pop_age
unique(pop_age$Age)
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.))))
_[!age %in% c("Total", "NotStated"),]
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
_[!age %in% c("Total", "NotStated"),]
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.))))
pop_age
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated"),]
unique(pop_age$age)
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated") & !str_detect(age, "\\-"),]
unique(pop_age$age)
View(pop_age)
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated") & !str_detect(age, "\\-"),] |>
_[, .(age, total)]
View(pop_age)
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated") & !str_detect(age, "\\-"),] |>
_[, .(age = str_replace_all(age, "\\+", ""), total)]
pop_age
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated") & !str_detect(age, "\\-"),] |>
_[, .(age = str_replace_all(age, "\\+", "") |> as.numeric(), total)]
pop_age
fwrite(pop_age, "data/pop_age.csv", row.names = F)
pop_age
pop_age |>
ggplot(aes(x = total)) +
geom_histogram() +
theme_minimal()
pop_age |>
ggplot(aes(x = age)) +
geom_histogram() +
theme_minimal()
pop_age |>
ggplot(aes(x = age)) +
geom_col(aes(y = total)) +
theme_minimal()
pop_age |>
ggplot(aes(x = age)) +
geom_col(aes(y = total)) +
theme_minimal() +
scale_y_continuous(labels = scales::label_comma())
reticulate::repl_python()
sum(pop_age$total)
require(reticulate)
repl_python()
pop_age <- rKenyaCensus::V3_T2.2 %>%
setNames(c(str_to_lower(colnames(.)))) |>
data.table() |>
_[!age %in% c("Total", "NotStated") & !str_detect(age, "\\-"),] |>
_[, .(age = str_replace_all(age, "\\+", "") |> as.numeric(), value = total)]
pop_age
reticulate::repl_python()
